# Production Setup Guide - GarudaVerify Full Stack

## Overview
Complete guide for deploying GarudaVerify (Frontend + Backend) to production environments.

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────┐
│                    End Users / Browsers                       │
└────────────────────────┬────────────────────────────────────┘
                         │
                    HTTPS/TLS
                         │
        ┌────────────────┴────────────────┐
        │                                 │
   ┌────▼──────┐                  ┌──────▼────┐
   │  Vercel   │                  │  Vercel   │
   │ (Frontend)│                  │(Middleware)
   │Next.js 14 │                  │   Auth    │
   └────┬──────┘                  └──────┬────┘
        │                                │
        └────────────────┬───────────────┘
                         │
                    API Calls
                    HTTPS/TLS
                         │
        ┌────────────────▼────────────────┐
        │                                 │
        │   Backend Server (Production)   │
        │  NestJS + PostgreSQL            │
        │  - Vercel Serverless Functions  │
        │  - Railway / Heroku / AWS       │
        │  - Self-hosted Docker           │
        │                                 │
        └────────────────┬────────────────┘
                         │
                         │
        ┌────────────────▼────────────────┐
        │   PostgreSQL Database           │
        │   - Managed (Railway, AWS RDS)  │
        │   - Self-hosted                 │
        └─────────────────────────────────┘
```

## Phase 1: Pre-Production Planning

### 1.1 Domain & DNS Setup

**For Frontend:**
```
garudaverify.com (or your domain)
├── A/CNAME → Vercel (auto-configured)
├── MX records → Email service (if needed)
└── TXT records → Domain verification
```

**For Backend API:**
```
api.garudaverify.com (or your domain)
├── A/CNAME → Backend hosting provider
├── SSL → Auto-generated by hosting provider
└── Redirects → Backend server
```

### 1.2 SSL/TLS Certificates
- Vercel: Automatic free SSL
- Backend: Let's Encrypt (free) or paid certificates
- Auto-renewal configured

### 1.3 Email Configuration (Optional)
- Transactional emails (NextAuth, notifications)
- Service: SendGrid, AWS SES, Mailgun, etc.
- Configure in backend `.env`

## Phase 2: Backend Deployment

### 2.1 Backend Hosting Options

#### Option A: Railway (Recommended for beginners)
```bash
# 1. Sign up at railway.app
# 2. Create new project
# 3. Connect GitHub repository
# 4. Set environment variables
# 5. Deploy

# Database: PostgreSQL add-on (automatic)
# Auto-generated domain: https://garudaverify-api-production.railway.app
```

#### Option B: Heroku
```bash
# Install Heroku CLI
brew tap heroku/brew && brew install heroku

# Login
heroku login

# Create app
heroku create garudaverify-api

# Add PostgreSQL
heroku addons:create heroku-postgresql:standard-0 -a garudaverify-api

# Deploy
git push heroku main

# View logs
heroku logs --tail
```

#### Option C: AWS (EC2 + RDS)
```bash
# 1. Create EC2 instance (Ubuntu 22.04)
# 2. Create RDS PostgreSQL database
# 3. Configure security groups
# 4. Install Node.js, PM2
# 5. Deploy via Git or Docker
# 6. Configure Nginx reverse proxy
# 7. Set up SSL with Certbot
```

#### Option D: Self-hosted Docker (VPS)
```bash
# 1. Rent VPS (DigitalOcean, Linode, etc.)
# 2. Install Docker & Docker Compose
# 3. Clone repository
# 4. Configure environment
# 5. Run docker-compose up -d
# 6. Set up Nginx reverse proxy
# 7. Configure SSL with Certbot
```

### 2.2 Backend Environment Variables

Create `.env` in `garudaverify-backend/`:

```env
# Server Configuration
NODE_ENV=production
PORT=8080

# Database
DATABASE_URL=postgresql://username:password@hostname:5432/garudaverify

# Authentication (Generate with: openssl rand -base64 32)
JWT_ACCESS_SECRET=your_secure_random_key_here
JWT_REFRESH_SECRET=another_secure_random_key_here

# JWT Expiry (in seconds)
JWT_ACCESS_EXPIRES=900           # 15 minutes
JWT_REFRESH_EXPIRES=1209600      # 14 days

# CORS Configuration
CORS_ORIGINS=https://garudaverify.com,https://www.garudaverify.com,https://garudaverify.vercel.app

# Optional: Email Configuration
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your-email@gmail.com
SMTP_PASS=your-app-password
SMTP_FROM=noreply@garudaverify.com

# Optional: Logging
LOG_LEVEL=info

# Optional: File Upload (AWS S3, etc.)
AWS_REGION=ap-south-1
AWS_ACCESS_KEY_ID=your_aws_key
AWS_SECRET_ACCESS_KEY=your_aws_secret
S3_BUCKET_NAME=garudaverify-uploads
```

### 2.3 Database Preparation

```bash
# Run migrations
npm run prisma:migrate:deploy

# Seed initial data (optional)
npm run seed

# Verify
npm run prisma:studio
```

### 2.4 Backend Health Check

```bash
# Test endpoint
curl https://api.garudaverify.com/health

# Expected response
{ "status": "ok", "timestamp": "2025-01-15T10:30:00Z" }
```

## Phase 3: Frontend Deployment to Vercel

### 3.1 Vercel Project Setup

```bash
# Login to Vercel
npm i -g vercel
vercel login

# Deploy production
cd garudaverify-frontend
vercel --prod
```

### 3.2 Environment Variables in Vercel

**Production Environment:**
```
NEXTAUTH_URL=https://garudaverify.com
NEXTAUTH_SECRET=[run: openssl rand -base64 32]
NEXT_PUBLIC_API_URL=https://api.garudaverify.com
```

### 3.3 Domain Configuration

1. Add custom domain in Vercel Settings
2. Update DNS to point to Vercel
3. Wait for SSL certificate generation (24 hours max)
4. Verify with: `https://garudaverify.com`

## Phase 4: Production Database Setup

### 4.1 Database Backup Strategy

```bash
# Daily backup (add to cron)
pg_dump postgresql://user:pass@host:5432/garudaverify | gzip > backup_$(date +%Y%m%d).sql.gz

# Store in AWS S3, Google Drive, or backup service
# Retention: Keep 30 days of daily backups, weekly for 3 months
```

### 4.2 Database Monitoring

- Set up alerts for disk space
- Monitor connection count
- Set up query performance monitoring
- Enable slow query logs

### 4.3 Database Maintenance

```bash
# Weekly maintenance
VACUUM ANALYZE;

# Monitor index usage
SELECT * FROM pg_stat_user_indexes;

# Check table sizes
SELECT schemaname, tablename, pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename))
FROM pg_tables
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

## Phase 5: Security Hardening

### 5.1 Network Security

**Backend API:**
- [ ] Enable HTTPS only
- [ ] Set HSTS header (Strict-Transport-Security)
- [ ] Enable CORS from trusted domains only
- [ ] Rate limiting configured
- [ ] DDoS protection enabled
- [ ] WAF rules configured

**Frontend:**
- [ ] Content Security Policy headers
- [ ] X-Frame-Options set to SAMEORIGIN
- [ ] X-Content-Type-Options set to nosniff
- [ ] Referrer-Policy configured

### 5.2 Authentication Security

```typescript
// Backend implementation
const corsOptions = {
  origin: process.env.CORS_ORIGINS?.split(','),
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  maxAge: 86400 // 24 hours
};
```

### 5.3 Secrets Management

- [ ] Never commit `.env` files
- [ ] Use environment variables for all secrets
- [ ] Rotate secrets every 90 days
- [ ] Use Vercel's built-in secret management
- [ ] Audit access logs

### 5.4 Data Encryption

- [ ] Database encryption at rest
- [ ] SSL/TLS for all data in transit
- [ ] Sensitive data encrypted in database
- [ ] PII handling compliant with GDPR/local laws

### 5.5 Monitoring & Logging

```bash
# Backend logs
tail -f /var/log/garudaverify/application.log

# Database logs
tail -f /var/log/postgresql/postgresql.log

# Frontend (Vercel logs)
vercel logs [deployment-url]
```

## Phase 6: Monitoring & Alerts

### 6.1 Set Up Monitoring

**Vercel Analytics:**
- Core Web Vitals (LCP, FID, CLS)
- Performance metrics
- Error tracking

**Backend Monitoring:**
- Application error logs
- Response time metrics
- Database performance
- CPU/Memory usage
- Network throughput

### 6.2 Alert Rules

Set up alerts for:
- Application errors (>5/min)
- 5xx errors (>1/min)
- API response time (>5000ms)
- Database connection pool exhausted
- Disk space low (<10% free)
- Memory usage high (>80%)

### 6.3 Health Checks

```bash
# Frontend health
curl -I https://garudaverify.com

# Backend health
curl https://api.garudaverify.com/health

# Database connection
curl https://api.garudaverify.com/health
```

## Phase 7: CI/CD Pipeline

### 7.1 GitHub Actions (Optional)

Create `.github/workflows/deploy.yml`:

```yaml
name: Deploy to Production

on:
  push:
    branches: [main]

jobs:
  deploy-backend:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Deploy to backend
        run: |
          # Add your deployment script
          echo "Deploying backend..."

  deploy-frontend:
    needs: deploy-backend
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Deploy to Vercel
        run: |
          vercel --prod --token ${{ secrets.VERCEL_TOKEN }}
```

## Phase 8: Rollback Procedures

### 8.1 Frontend Rollback

```bash
# In Vercel Dashboard
# Deployments → Select previous deployment → Promote to Production
```

### 8.2 Backend Rollback

```bash
# For Railway
# Deployments → Select previous deployment → Redeploy

# For Heroku
heroku releases
heroku rollback v123

# For self-hosted
# Git rollback + restart
git revert <commit-hash>
pm2 restart garudaverify-api
```

## Phase 9: Performance Optimization

### 9.1 Frontend Optimization

- [ ] Images optimized (WebP, responsive sizes)
- [ ] Code splitting enabled
- [ ] CSS minified
- [ ] JavaScript minified
- [ ] Caching headers configured
- [ ] CDN enabled (Vercel default)

### 9.2 Backend Optimization

- [ ] Database indexes optimized
- [ ] Query performance reviewed
- [ ] Caching strategy implemented (Redis optional)
- [ ] Connection pooling configured
- [ ] Compression enabled (Gzip)

### 9.3 Database Optimization

```sql
-- Create indexes for frequently queried columns
CREATE INDEX idx_user_email ON "User"(email);
CREATE INDEX idx_request_status ON "VerificationRequest"(status);
CREATE INDEX idx_request_created ON "VerificationRequest"(createdAt);

-- Analyze query plans
EXPLAIN ANALYZE SELECT * FROM "VerificationRequest" WHERE status = 'PENDING';
```

## Phase 10: Post-Launch Monitoring

### 10.1 First Week Checklist

- [ ] Monitor error rates
- [ ] Check performance metrics
- [ ] User feedback collected
- [ ] Critical bugs fixed
- [ ] Security scan completed
- [ ] Backup tested
- [ ] Logging verified

### 10.2 Weekly Tasks

- [ ] Review logs for errors
- [ ] Check performance trends
- [ ] Database maintenance
- [ ] Backup integrity verification
- [ ] Security updates applied
- [ ] Analytics review

### 10.3 Monthly Tasks

- [ ] Performance audit
- [ ] Security audit
- [ ] Database optimization
- [ ] Dependency updates
- [ ] Cost analysis
- [ ] Capacity planning

## Deployment Checklist

```
PRE-PRODUCTION
[ ] All tests passing
[ ] No console errors
[ ] Security audit complete
[ ] Performance benchmarks acceptable
[ ] Secrets not in code
[ ] Environment variables documented

BACKEND DEPLOYMENT
[ ] Database created and migrated
[ ] Environment variables set
[ ] API endpoints accessible
[ ] CORS configured
[ ] SSL/TLS enabled
[ ] Health check working
[ ] Backups configured

FRONTEND DEPLOYMENT
[ ] Build successful locally
[ ] Environment variables set in Vercel
[ ] Domain configured
[ ] SSL/TLS certificate issued
[ ] Authentication working
[ ] API integration working
[ ] Tests passing

MONITORING
[ ] Error alerts configured
[ ] Performance monitoring enabled
[ ] Logging configured
[ ] Backup verification complete
[ ] Incident response plan ready

LAUNCH
[ ] Announce deployment
[ ] Monitor closely for 24 hours
[ ] Prepare rollback if needed
[ ] Engage support team
[ ] Document any issues
```

## Support & Resources

- [Vercel Documentation](https://vercel.com/docs)
- [Next.js Production Checklist](https://nextjs.org/docs/going-to-production)
- [NestJS Deployment Guide](https://docs.nestjs.com/deployment)
- [PostgreSQL Administration](https://www.postgresql.org/docs/current/admin.html)
